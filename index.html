<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Souyette Card Game Fight</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .header {
            background-color: #34495e;
            padding: 15px 20px;
            text-align: center;
            font-size: 1.5em;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
            width: 100%;
            z-index: 100;
        }
        .tabs {
            display: flex;
            justify-content: center;
            background-color: #34495e;
            padding: 10px 0;
            border-bottom: 2px solid #2c3e50;
        }
        .tab-button {
            background-color: #2980b9;
            color: white;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            margin: 0 5px;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .tab-button:hover {
            background-color: #3498db;
            transform: translateY(-2px);
        }
        .tab-button.active {
            background-color: #e67e22; /* Orange vif pour l'onglet actif */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform: translateY(-3px);
        }
        .tab-content {
            display: none;
            padding: 20px;
            flex-grow: 1;
            overflow-y: auto;
            width: 100%;
            box-sizing: border-box;
        }
        .tab-content.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Styles pour la Gestion des Decks --- */
        #deck-management {
            max-width: 900px;
            width: 100%;
        }
        .deck-controls {
            background-color: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .deck-controls input, .deck-controls button, .deck-controls select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #7f8c8d;
            background-color: #ecf0f1;
            color: #2c3e50;
            width: 100%;
            max-width: 300px;
            box-sizing: border-box;
        }
        .deck-controls button {
            background-color: #27ae60;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .deck-controls button:hover {
            background-color: #2ecc71;
        }
        .deck-list {
            margin-top: 15px;
            border-top: 1px solid #7f8c8d;
            padding-top: 15px;
            width: 100%;
        }
        .deck-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px dashed #7f8c8d;
            background-color: #2c3e50;
            margin-bottom: 5px;
            border-radius: 5px;
        }
        .deck-item:last-child {
            border-bottom: none;
        }
        .deck-item button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-left: 5px;
            max-width: none; /* Override max-width for these buttons */
            width: auto;
        }
        .deck-item button.delete-btn {
            background-color: #e74c3c;
        }
        .deck-item button:hover {
            background-color: #2980b9;
        }
        .deck-item button.delete-btn:hover {
            background-color: #c0392b;
        }
        .deck-name-display {
            flex-grow: 1;
            font-size: 1.1em;
            font-weight: bold;
        }
        .current-deck-display {
            background-color: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 100%;
            box-sizing: border-box;
        }
        .current-deck-display h2 {
            text-align: center;
            margin-top: 0;
            color: #ecf0f1;
        }
        .current-deck-stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px dashed #7f8c8d;
            border-radius: 5px;
        }
        .current-deck-stats div {
            text-align: center;
            font-size: 0.9em;
        }
        .current-deck-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            padding: 10px;
            background-color: #2c3e50;
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
        }
        .current-deck-cards-grid .card-preview {
            width: 100px;
            height: 150px;
            cursor: default; /* No click action for cards in current deck display */
            border: 2px solid #7f8c8d;
        }
        .current-deck-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .current-deck-actions button {
            background-color: #2ecc71;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .current-deck-actions button:hover {
            background-color: #27ae60;
        }
        .current-deck-actions button.cancel {
            background-color: #e74c3c;
        }
        .current-deck-actions button.cancel:hover {
            background-color: #c0392b;
        }
        .current-deck-actions input {
            flex-grow: 1;
            max-width: 250px;
        }


        /* --- Styles pour le Duel (adaptés pour un seul joueur) --- */
        #duel {
            justify-content: center;
            width: 100%;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            width: 95%;
            max-width: 600px;
            min-height: calc(100vh - 120px);
            justify-content: flex-start;
            align-items: center;
            overflow-y: auto;
        }
        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            flex-grow: 1;
            padding: 10px;
            box-sizing: border-box;
            position: relative;
            margin-bottom: 20px;
            margin-top: 20px;
        }
        .card {
            width: 80px;
            height: 120px;
            background-color: #555;
            border: 2px solid #7f8c8d;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: white;
            text-align: center;
            background-size: cover;
            background-position: center;
            user-select: none;
            transition: transform 0.1s ease-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .card:active {
            transform: scale(0.98);
        }
        .card.empty-slot {
            background-color: rgba(0, 0, 0, 0.1);
            border: 2px dashed #7f8c8d;
            cursor: default;
            color: #95a5a6;
            font-size: 0.8em;
            box-shadow: none;
        }
        .card img {
            max-width: 100%;
            max-height: 100%;
            border-radius: 6px;
            display: block;
            pointer-events: none;
        }
        /* Nouvelle classe pour la rotation */
        .card.rotated {
            transform: rotate(90deg);
            transform-origin: center center;
            width: 120px; /* Ancien height */
            height: 80px; /* Ancien width */
        }
        .card.rotated img {
            max-width: 100%;
            max-height: 100%;
        }

.board {
    display: grid;
    /* Conservez ces propriétés pour les écrans plus grands, si nécessaire */
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 5px;
    width: 75%;
    max-width: 450px;
    height: auto;
    max-height: 400px;
    border: 2px solid #34495e;
    background-color: #34495e;
    padding: 5px;
    border-radius: 10px;
    margin-bottom: 10px;
    position: relative;
    z-index: 10;
}

@media (max-width: 450px) {
    .board {
        /* Chaque colonne aura une taille minimale de 50px et maximale de 1 fraction */
        grid-template-columns: repeat(5, minmax(50px, 1fr));
        width: 98vw; /* Ou 95vw, pour être sûr */
        gap: 2px; /* Réduisez encore le gap */
        padding: 2px; /* Réduisez encore le padding */
    }
}
        .board-slot {
            width: 80px;
            height: 120px;
            background-color: #2c3e50;
            border: 1px dashed #7f8c8d;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7em;
            color: #95a5a6;
            transition: background-color 0.2s;
            z-index: 1;
        }
        .board-slot.targetable {
            background-color: #3498db;
            cursor: pointer;
        }
        .board-slot.targetable:hover {
            background-color: #2980b9;
        }
        .deck-graveyard-area {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            position: relative;
        }
        .deck, .graveyard {
            width: 80px;
            height: 120px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .deck:hover, .graveyard:hover {
            background-color: #34495e;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .deck { background-color: #27ae60; }
        .graveyard { background-color: #c0392b; }
        .deck span, .graveyard span {
            font-size: 0.8em;
            margin-top: 5px;
            color: #ecf0f1;
        }
        .hand {
            display: flex;
            min-height: 130px;
            width: 100%;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 5px;
            border: 1px dashed rgba(236, 240, 241, 0.3);
            border-radius: 5px;
            padding: 5px;
            box-sizing: border-box;
            background-color: rgba(0, 0, 0, 0.2);
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out, border-color 0.3s ease-out;
            max-height: 130px;
            overflow-y: auto;
            position: relative;
        }
        .hand.hidden {
            max-height: 0;
            opacity: 0;
            padding: 0 5px;
            border-color: transparent;
        }
        .toggle-hand-btn {
            background-color: #3498db;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 5px;
            font-size: 0.9em;
            align-self: center;
            transition: background-color 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .toggle-hand-btn:hover {
            background-color: #2980b9;
        }
        .lp-counter {
            background-color: rgba(44, 62, 80, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .lp-counter button {
            background-color: #95a5a6;
            color: #2c3e50;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 1.2em;
            cursor: pointer;
            margin: 0 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        .lp-counter button:hover {
            background-color: #bdc3c7;
        }
        .lp-value {
            min-width: 50px;
            text-align: center;
            color: #ecf0f1;
        }
        .card-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .card-modal.active {
            display: flex;
        }
        .modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #34495e;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            position: relative;
            transform: scale(0.95);
            animation: fadeInScale 0.3s forwards;
        }
        @keyframes fadeInScale {
            to { transform: scale(1); opacity: 1; }
        }
        .modal-card-display {
            width: 333px;
            height: 500px;
            border: 3px solid #ecf0f1;
            border-radius: 10px;
            background-size: cover;
            background-position: center;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .modal-actions button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .modal-actions button:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }
        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 2.5em;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            transition: color 0.2s, transform 0.1s;
        }
        .modal-close:hover {
            color: #e74c3c;
            transform: rotate(5deg);
        }
        .deck-graveyard-menu {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .deck-graveyard-menu.active {
            display: flex;
        }
        .menu-content {
            background-color: #34495e;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            position: relative;
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            animation: fadeInScale 0.3s forwards;
        }
        .menu-content h2 {
            margin-top: 0;
            color: #ecf0f1;
            margin-bottom: 15px;
        }
        .menu-options button {
            background-color: #28a745;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin: 5px;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .menu-options button:hover {
            background-color: #218838;
            transform: translateY(-1px);
        }
        .menu-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 2.5em;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            transition: color 0.2s, transform 0.1s;
        }
        .menu-close:hover {
            color: #e74c3c;
            transform: rotate(5deg);
        }
        .card-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
            background-color: #2c3e50;
            border-radius: 8px;
            margin-top: 15px;
            flex-grow: 1;
        }
        .card-selection-grid .card {
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .card-selection-grid .card:hover {
            border-color: #3498db;
        }
        .card-selection-grid .card.selected-for-move {
            border-color: #f1c40f;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.8);
        }

        /* --- Modals de création/édition de deck (Nouveaux) --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s forwards;
        }
        .modal.active {
            display: flex;
        }
        .modal-content-deck-builder {
            background-color: #34495e;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 900px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
            animation: slideIn 0.3s forwards;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }
        .modal-content-card-selector {
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            overflow: hidden;
        }
        .modal-content-card-detail {
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .modal-content-deck-builder h2, .modal-content-card-selector h2, .modal-content-card-detail h2 {
            margin-top: 0;
            color: #ecf0f1;
            text-align: center;
            margin-bottom: 20px;
        }
        .modal .close-button {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .modal .close-button:hover,
        .modal .close-button:focus {
            color: #ecf0f1;
            text-decoration: none;
            cursor: pointer;
        }
        .modal-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            padding: 10px;
            background-color: #2c3e50;
            border-radius: 8px;
            flex-grow: 1;
            overflow-y: auto;
        }
        .modal-card-grid .card-preview {
            width: 100px;
            height: 150px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .modal-card-grid .card-preview:hover {
            border-color: #3498db;
        }
        .selected-card-preview {
            width: 200px;
            height: 300px;
            border: 3px solid #ecf0f1;
            border-radius: 10px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .card-detail-actions {
            display: flex;
            gap: 10px;
        }
        .card-detail-actions button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }
        .card-detail-actions .add-card-btn { background-color: #28a745; }
        .card-detail-actions .add-card-btn:hover { background-color: #218838; }
        .card-detail-actions .cancel-card-btn { background-color: #e74c3c; }
        .card-detail-actions .cancel-card-btn:hover { background-color: #c0392b; }

        #currentEditingDeckNameInput {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #7f8c8d;
            background-color: #ecf0f1;
            color: #2c3e50;
            width: calc(100% - 20px);
            max-width: 300px;
            margin-bottom: 20px;
            text-align: center;
            box-sizing: border-box;
        }
        .card-preview {
            position: relative; /* Nécessaire pour positionner le bouton */
        }
        .remove-card-btn {
            position: absolute;
            top: -8px; /* Ajustez pour qu'il soit bien en haut à droite */
            right: -8px; /* Ajustez pour qu'il soit bien en haut à droite */
            background-color: #e74c3c; /* Couleur rouge pour supprimer */
            color: white;
            border: none;
            border-radius: 50%; /* Pour un bouton rond */
            width: 20px;
            height: 20px;
            font-size: 1.2em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: background-color 0.2s, transform 0.1s;
            z-index: 5; /* Assurez-vous qu'il est au-dessus de la carte */
        }
        .remove-card-btn:hover {
            background-color: #c0392b;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="tabs">
        <button class="tab-button active" data-tab="deck-management">Gestion des Decks</button>
        <button class="tab-button" data-tab="duel">Duel</button>
    </div>

    <div id="deck-management" class="tab-content active">
        <div class="deck-controls">
            <button id="addNewCardBtn">Ajouter une carte au deck en cours</button>
            <input type="text" id="currentEditingDeckNameInput" placeholder="Nom du deck en cours" disabled>

            <div class="current-deck-display" id="currentDeckDisplayArea">
                <h2>Deck en cours</h2>
                <div class="current-deck-stats">
                    <div>Total: <span id="currentDeckTotalCards">0</span> / 50</div>
                    <div>PE: <span id="currentDeckPeCount">0</span> / 20</div>
                    <div>OB: <span id="currentDeckObCount">0</span> / 15</div>
                    <div>PI: <span id="currentDeckPiCount">0</span> / 15</div>
                </div>
                <div id="currentDeckCardsGrid" class="current-deck-cards-grid">
                    </div>
                <div class="current-deck-actions">
                    <button id="saveCurrentDeckBtn">Valider le Deck</button>
                    <button id="cancelCurrentDeckBtn" class="cancel">Annuler</button>
                    <button id="clearCurrentDeckBtn" class="cancel">Vider</button>
                </div>
            </div>

            <h2 style="width: 100%; text-align: center; margin-top: 20px;">Mes Decks Sauvegardés</h2>
            <div id="deck-list" class="deck-list">
                </div>
        </div>
    </div>

    <div id="duel" class="tab-content">
        <div class="game-container">
            <div class="player-area player1">
                <div class="lp-counter">
                    <button class="lp-minus" data-player="1">-</button>
                    <span class="lp-value" id="lp1">8000</span>
                    <button class="lp-plus" data-player="1">+</button>
                </div>
                <div class="board" id="board1">
                    </div>
                <div class="deck-graveyard-area">
                    <div class="deck" id="deck1"><span>Deck</span></div>
                    <div class="graveyard" id="graveyard1"><span>Cimetière</span></div>
                </div>
                <button class="toggle-hand-btn" data-player="1">Masquer Ma Main</button>
                <div class="hand" id="hand1">
                    </div>
            </div>
            </div>

        <div class="card-modal" id="cardModal">
            <div class="modal-content">
                <button class="modal-close" id="modalCloseBtn">&times;</button>
                <div class="modal-card-display" id="modalCardDisplay"></div>
                <div class="modal-actions">
                    <button id="modalMoveCardBtn">Déplacer sur le plateau</button>
                    <button id="modalTakeToHandBtn">Prendre en main</button> <button id="modalRotateCardBtn">Pivoter (90°)</button>
                    <button id="modalFaceDownRotateCardBtn">Face cachée & pivotée</button>
                    <button id="modalGraveyardBtn">Cimetière</button>
                    <button id="modalDeckBtn">Deck</button>
                </div>
            </div>
        </div>

        <div class="deck-graveyard-menu" id="deckGraveyardMenu">
            <div class="menu-content">
                <button class="menu-close" id="menuCloseBtn">&times;</button>
                <h2 id="menuTitle"></h2>
                <div class="menu-options" id="menuOptions">
                    </div>
                <div class="card-selection-grid" id="cardSelectionGrid">
                    </div>
            </div>
        </div>

        <div class="modal" id="selectDeckModal">
            <div class="modal-content-deck-builder">
                <span class="close-button" id="closeSelectDeckModal">&times;</span>
                <h2>Sélectionner un Deck</h2>
                <div id="available-decks-list">
                    </div>
                <button id="start-duel-with-selected-deck" style="background-color: #3498db; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">Démarrer le Duel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="addCardToDeckModal">
        <div class="modal-content-card-selector">
            <span class="close-button" id="closeAddCardToDeckModal">&times;</span>
            <h2>Ajouter une carte</h2>
            <div class="modal-card-grid" id="addCardModalGrid">
                </div>
        </div>
    </div>

    <div class="modal" id="cardDetailModal">
        <div class="modal-content-card-detail">
            <span class="close-button" id="closeCardDetailModal">&times;</span>
            <div class="selected-card-preview" id="detailCardDisplay"></div>
            <div class="card-detail-actions">
                <button class="add-card-btn" id="addCardToCurrentDeckBtn">Ajouter au Deck</button>
                <button class="cancel-card-btn" id="cancelAddCardBtn">Annuler</button>
            </div>
        </div>
    </div>

    <div class="modal" id="viewDeckModal">
        <div class="modal-content-card-selector">
            <span class="close-button" id="closeViewDeckModal">&times;</span>
            <h2 id="viewDeckModalTitle">Cartes du Deck</h2>
            <div class="modal-card-grid" id="viewDeckCardsGrid">
                </div>
        </div>
    </div>


    <script>
        // --- Configuration Générale ---
        const MIN_DECK_SIZE = 50;
        const TOTAL_PE_CARDS = 126;
        const TOTAL_OB_CARDS = 67;
        const TOTAL_PI_CARDS = 62;

        // Limites strictes par type de carte
        const MAX_PE_CARDS = 20;
        const MAX_OB_CARDS = 15;
        const MAX_PI_CARDS = 15;

        // --- Variables Globales pour l'état du jeu ---
        let allAvailableCards = []; // Liste de toutes les cartes disponibles
        let savedDecks = {}; // Stockage des decks par nom
        let currentEditingDeck = { name: '', cards: [] }; // Deck en cours de modification/création

        // Un seul joueur maintenant
        let player1 = { deck: [], hand: [], graveyard: [], board: Array(15).fill(null), lp: 60, selectedDeckName: null }; // Board size changed to 15
        let players = { '1': player1 }; // L'objet players ne contient plus que le joueur 1

        let selectedCard = { element: null, data: null, location: null, player: null, boardIndex: null, menuOrigin: null, isFaceDown: false, isRotated: false }; // Added isFaceDown and isRotated
        let isMovingCard = false;
        let cardToAddToCurrentDeck = null; // Carte sélectionnée dans addCardToDeckModal pour ajout

        // --- Références DOM Générales pour le duel ---
        const cardModal = document.getElementById('cardModal');
        const modalCardDisplay = document.getElementById('modalCardDisplay');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalMoveCardBtn = document.getElementById('modalMoveCardBtn');
        const modalGraveyardBtn = document.getElementById('modalGraveyardBtn');
        const modalDeckBtn = document.getElementById('modalDeckBtn');
        // New buttons
        const modalRotateCardBtn = document.getElementById('modalRotateCardBtn');
        const modalFaceDownRotateCardBtn = document.getElementById('modalFaceDownRotateCardBtn');
        const modalTakeToHandBtn = document.getElementById('modalTakeToHandBtn'); // NOUVEAU
        const deckGraveyardMenu = document.getElementById('deckGraveyardMenu');
        const menuCloseBtn = document.getElementById('menuCloseBtn');
        const menuTitle = document.getElementById('menuTitle');
        const menuOptions = document.getElementById('menuOptions');
        const cardSelectionGrid = document.getElementById('cardSelectionGrid');


        // --- Références DOM Duel (inchangées) ---
        const duelTab = document.getElementById('duel');
        const lpCounters = { '1': document.getElementById('lp1') };
        const boards = { '1': document.getElementById('board1') };
        const decks = { '1': document.getElementById('deck1') };
        const graveyards = { '1': document.getElementById('graveyard1') };
        const hands = { '1': document.getElementById('hand1') };
        const toggleHandBtns = document.querySelectorAll('.toggle-hand-btn');

        const selectDeckModal = document.getElementById('selectDeckModal');
        const closeSelectDeckModal = document.getElementById('closeSelectDeckModal');
        const availableDecksList = document.getElementById('available-decks-list');
        const startDuelWithSelectedDeckBtn = document.getElementById('start-duel-with-selected-deck');


        // --- Références DOM Gestion des Decks (Nouvelles/modifiées) ---
        const deckManagementTab = document.getElementById('deck-management');
        const addNewCardBtn = document.getElementById('addNewCardBtn');
        const currentEditingDeckNameInput = document.getElementById('currentEditingDeckNameInput');
        const currentDeckTotalCards = document.getElementById('currentDeckTotalCards');
        const currentDeckPeCount = document.getElementById('currentDeckPeCount');
        const currentDeckObCount = document.getElementById('currentDeckObCount');
        const currentDeckPiCount = document.getElementById('currentDeckPiCount');
        const currentDeckCardsGrid = document.getElementById('currentDeckCardsGrid');
        const saveCurrentDeckBtn = document.getElementById('saveCurrentDeckBtn');
        const cancelCurrentDeckBtn = document.getElementById('cancelCurrentDeckBtn');
        const clearCurrentDeckBtn = document.getElementById('clearCurrentDeckBtn');
        const deckListDiv = document.getElementById('deck-list');

        // Nouveaux Modals de gestion de deck
        const addCardToDeckModal = document.getElementById('addCardToDeckModal');
        const closeAddCardToDeckModal = document.getElementById('closeAddCardToDeckModal');
        const addCardModalGrid = document.getElementById('addCardModalGrid');

        const cardDetailModal = document.getElementById('cardDetailModal');
        const closeCardDetailModal = document.getElementById('closeCardDetailModal');
        const detailCardDisplay = document.getElementById('detailCardDisplay');
        const addCardToCurrentDeckBtn = document.getElementById('addCardToCurrentDeckBtn');
        const cancelAddCardBtn = document.getElementById('cancelAddCardBtn');

        const viewDeckModal = document.getElementById('viewDeckModal');
        const closeViewDeckModal = document.getElementById('closeViewDeckModal');
        const viewDeckModalTitle = document.getElementById('viewDeckModalTitle');
        const viewDeckCardsGrid = document.getElementById('viewDeckCardsGrid');


        // --- Fonctions Utilitaires ---
        function getCardImagePath(type, number) {
            const paddedNumber = String(number).padStart(3, '0');
            return `images/${type}/${type}_${paddedNumber}.jpg`;
        }

        function createCardElement(cardData, isFaceDown = false, isPreview = false, isRemovable = false, isRotated = false) { // Added isRotated
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card');
            if (isPreview) cardDiv.classList.add('card-preview');
            if (isRotated) cardDiv.classList.add('rotated'); // New class for rotation
            cardDiv.dataset.cardId = cardData.id;
            cardDiv.dataset.imagePath = cardData.path;
            cardDiv.dataset.cardType = cardData.type;
            cardDiv.dataset.isFaceDown = isFaceDown; // New data attribute
            cardDiv.dataset.isRotated = isRotated; // New data attribute

            if (isFaceDown) {
                cardDiv.style.backgroundImage = `url(images/dos.jpg)`; // Image de dos de carte
                cardDiv.style.backgroundSize = 'cover';
                cardDiv.style.backgroundPosition = 'center';
                cardDiv.textContent = ''; // Pas de texte si c'est le dos
            } else {
                const img = document.createElement('img');
                img.src = cardData.path;
                img.alt = `Carte ${cardData.id}`;
                cardDiv.appendChild(img);

                // La partie suivante pour afficher l'ID de la carte a été commentée
                // ou supprimée si vous avez suivi les instructions précédentes.
                // Si vous souhaitez remettre l'ID, décommentez ou réécrivez :
                // if (isPreview) {
                //     const span = document.createElement('span');
                //     span.textContent = cardData.id;
                //     cardDiv.appendChild(span);
                // }

                // AJOUT POUR LE BOUTON DE SUPPRESSION
                if (isRemovable) {
                    const removeBtn = document.createElement('button');
                    removeBtn.classList.add('remove-card-btn');
                    removeBtn.textContent = '-';
                    removeBtn.title = 'Retirer du deck';
                    removeBtn.dataset.cardId = cardData.id; // Stocke l'ID pour la suppression
                    cardDiv.appendChild(removeBtn);
                }
            }
            return cardDiv;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Gestion des Decks (Nouvelles fonctions) ---
        function generateAllAvailableCards() {
            let cards = [];
            for (let i = 1; i <= TOTAL_PE_CARDS; i++) {
                cards.push({ id: `PE_${String(i).padStart(3, '0')}`, path: getCardImagePath('PE', i), type: 'PE' });
            }
            for (let i = 1; i <= TOTAL_OB_CARDS; i++) {
                cards.push({ id: `OB_${String(i).padStart(3, '0')}`, path: getCardImagePath('OB', i), type: 'OB' });
            }
            for (let i = 1; i <= TOTAL_PI_CARDS; i++) {
                cards.push({ id: `PI_${String(i).padStart(3, '0')}`, path: getCardImagePath('PI', i), type: 'PI' });
            }
            allAvailableCards = cards.sort((a, b) => a.id.localeCompare(b.id)); // Trie par ID pour un affichage cohérent
        }

        function loadSavedDecks() {
            const storedDecks = localStorage.getItem('savedDecks');
            if (storedDecks) {
                savedDecks = JSON.parse(storedDecks);
            }
            renderDeckList();
        }

        function saveDeck(deckName, cards) {
            savedDecks[deckName] = cards;
            localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
            renderDeckList();
            alert(`Deck "${deckName}" sauvegardé !`);
        }

        function deleteDeck(deckName) {
            if (confirm(`Êtes-vous sûr de vouloir supprimer le deck "${deckName}" ?`)) {
                delete savedDecks[deckName];
                localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
                renderDeckList();
                // Si le deck supprimé était le deck en cours, vider l'éditeur
                if (currentEditingDeck.name === deckName) {
                    currentEditingDeck = { name: '', cards: [] };
                    updateCurrentDeckDisplay();
                    currentEditingDeckNameInput.value = '';
                    currentEditingDeckNameInput.disabled = true;
                }
                alert(`Deck "${deckName}" supprimé.`);
            }
        }

        function renderDeckList() {
            deckListDiv.innerHTML = '';
            if (Object.keys(savedDecks).length === 0) {
                deckListDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Aucun deck sauvegardé pour le moment.</p>';
                return;
            }
            for (const name in savedDecks) {
                const deckItem = document.createElement('div');
                deckItem.classList.add('deck-item');
                const deckNameSpan = document.createElement('span');
                deckNameSpan.classList.add('deck-name-display');
                deckNameSpan.textContent = `${name} (${savedDecks[name].length} cartes)`;
                deckItem.appendChild(deckNameSpan);

                const actionsDiv = document.createElement('div');

                const editBtn = document.createElement('button');
                editBtn.textContent = 'Éditer';
                editBtn.addEventListener('click', () => editDeck(name));
                actionsDiv.appendChild(editBtn);

                const viewBtn = document.createElement('button');
                viewBtn.textContent = 'Voir';
                viewBtn.addEventListener('click', () => viewDeck(name));
                actionsDiv.appendChild(viewBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Supprimer';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.addEventListener('click', () => deleteDeck(name));
                actionsDiv.appendChild(deleteBtn);

                deckItem.appendChild(actionsDiv);
                deckListDiv.appendChild(deckItem);
            }
        }

        function editDeck(deckName) {
            currentEditingDeck.name = deckName;
            currentEditingDeck.cards = [...savedDecks[deckName]]; // Copie pour éviter la modification directe
            currentEditingDeckNameInput.value = deckName;
            currentEditingDeckNameInput.disabled = false;
            updateCurrentDeckDisplay();
        }

        function viewDeck(deckName) {
            const cardsToDisplay = savedDecks[deckName];
            viewDeckModalTitle.textContent = `Cartes du Deck : ${deckName} (${cardsToDisplay.length} cartes)`;
            viewDeckCardsGrid.innerHTML = '';
            cardsToDisplay.forEach(cardData => {
                const cardElement = createCardElement(cardData, false, true); // isPreview = true
                viewDeckCardsGrid.appendChild(cardElement);
            });
            viewDeckModal.classList.add('active');
        }


        function updateCurrentDeckDisplay() {
            currentDeckCardsGrid.innerHTML = '';
            let peCount = 0;
            let obCount = 0;
            let piCount = 0;

            currentEditingDeck.cards.forEach(cardData => {
                const cardElement = createCardElement(cardData, false, true, true); // isPreview, isRemovable
                currentDeckCardsGrid.appendChild(cardElement);

                // Incrémenter les compteurs par type
                if (cardData.type === 'PE') peCount++;
                else if (cardData.type === 'OB') obCount++;
                else if (cardData.type === 'PI') piCount++;
            });

            currentDeckTotalCards.textContent = currentEditingDeck.cards.length;
            currentDeckPeCount.textContent = `${peCount} / ${MAX_PE_CARDS}`;
            currentDeckObCount.textContent = `${obCount} / ${MAX_OB_CARDS}`;
            currentDeckPiCount.textContent = `${piCount} / ${MAX_PI_CARDS}`;

            // Mettre à jour la couleur des compteurs si les limites sont dépassées
            currentDeckPeCount.style.color = peCount > MAX_PE_CARDS ? 'red' : '';
            currentDeckObCount.style.color = obCount > MAX_OB_CARDS ? 'red' : '';
            currentDeckPiCount.style.color = piCount > MAX_PI_CARDS ? 'red' : '';
        }

        function showAddCardModal() {
            addCardModalGrid.innerHTML = '';
            allAvailableCards.forEach(cardData => {
                const cardElement = createCardElement(cardData, false, true); // isPreview = true
                cardElement.addEventListener('click', () => showCardDetailModal(cardData));
                addCardModalGrid.appendChild(cardElement);
            });
            addCardToDeckModal.classList.add('active');
        }

        function showCardDetailModal(cardData) {
            cardToAddToCurrentDeck = cardData; // Stocke la carte pour l'ajout
            detailCardDisplay.style.backgroundImage = `url(${cardData.path})`;
            detailCardDisplay.style.backgroundSize = 'cover';
            detailCardDisplay.style.backgroundPosition = 'center';
            cardDetailModal.classList.add('active');
        }

        function addCardToCurrentDeck() {
            if (cardToAddToCurrentDeck) {
                // Vérifier si le deck est en mode édition (nom non vide)
                if (!currentEditingDeck.name) {
                    alert("Veuillez d'abord nommer ou sélectionner un deck à éditer.");
                    return;
                }

                // Vérifier les limites de types de cartes
                const currentPeCount = currentEditingDeck.cards.filter(c => c.type === 'PE').length;
                const currentObCount = currentEditingDeck.cards.filter(c => c.type === 'OB').length;
                const currentPiCount = currentEditingDeck.cards.filter(c => c.type === 'PI').length;

                if (cardToAddToCurrentDeck.type === 'PE' && currentPeCount >= MAX_PE_CARDS) {
                    alert(`Vous ne pouvez pas avoir plus de ${MAX_PE_CARDS} cartes PE dans votre deck.`);
                    return;
                }
                if (cardToAddToCurrentDeck.type === 'OB' && currentObCount >= MAX_OB_CARDS) {
                    alert(`Vous ne pouvez pas avoir plus de ${MAX_OB_CARDS} cartes OB dans votre deck.`);
                    return;
                }
                if (cardToAddToCurrentDeck.type === 'PI' && currentPiCount >= MAX_PI_CARDS) {
                    alert(`Vous ne pouvez pas avoir plus de ${MAX_PI_CARDS} cartes PI dans votre deck.`);
                    return;
                }
                
                // Ajouter la carte au deck en cours
                currentEditingDeck.cards.push(cardToAddToCurrentDeck);
                updateCurrentDeckDisplay(); // Mettre à jour l'affichage
                cancelAddCard(); // Fermer les modales après l'ajout
            }
        }

        function cancelAddCard() {
            cardToAddToCurrentDeck = null;
            cardDetailModal.classList.remove('active');
            addCardToDeckModal.classList.remove('active');
        }

        function saveCurrentDeck() {
            const deckName = currentEditingDeckNameInput.value.trim();
            if (!deckName) {
                alert("Veuillez donner un nom à votre deck.");
                return;
            }
            if (currentEditingDeck.cards.length < MIN_DECK_SIZE) {
                alert(`Votre deck doit contenir au moins ${MIN_DECK_SIZE} cartes.`);
                return;
            }

            // Vérifier les limites finales de types de cartes avant de sauvegarder
            const currentPeCount = currentEditingDeck.cards.filter(c => c.type === 'PE').length;
            const currentObCount = currentEditingDeck.cards.filter(c => c.type === 'OB').length;
            const currentPiCount = currentEditingDeck.cards.filter(c => c.type === 'PI').length;

            if (currentPeCount > MAX_PE_CARDS || currentObCount > MAX_OB_CARDS || currentPiCount > MAX_PI_CARDS) {
                alert("Veuillez respecter les limites de types de cartes avant de sauvegarder.");
                return;
            }

            saveDeck(deckName, currentEditingDeck.cards);
            currentEditingDeck = { name: '', cards: [] }; // Réinitialiser
            currentEditingDeckNameInput.value = '';
            currentEditingDeckNameInput.disabled = true;
            updateCurrentDeckDisplay();
        }

        function cancelCurrentDeckEditing() {
            if (confirm("Annuler les modifications ? Le deck actuel sera vidé si non sauvegardé.")) {
                currentEditingDeck = { name: '', cards: [] };
                currentEditingDeckNameInput.value = '';
                currentEditingDeckNameInput.disabled = true;
                updateCurrentDeckDisplay();
            }
        }

        function clearCurrentDeck() {
            if (confirm("Voulez-vous vraiment vider le deck en cours ? Cette action est irréversible pour les modifications non sauvegardées.")) {
                currentEditingDeck.cards = [];
                updateCurrentDeckDisplay();
            }
        }

        // Fonction pour gérer la suppression d'une carte du deck en cours
        function removeCardFromCurrentDeck(cardId) {
            const initialLength = currentEditingDeck.cards.length;
            currentEditingDeck.cards = currentEditingDeck.cards.filter(card => card.id !== cardId);
            if (currentEditingDeck.cards.length < initialLength) {
                updateCurrentDeckDisplay();
            }
        }

        // Ajoutez l'écouteur d'événements pour les boutons de suppression de carte
        currentDeckCardsGrid.addEventListener('click', (event) => {
            if (event.target.classList.contains('remove-card-btn')) {
                const cardIdToRemove = event.target.dataset.cardId;
                removeCardFromCurrentDeck(cardIdToRemove);
            }
        });


        // --- Fonctions Duel (modifiées/ajoutées) ---
        function resetSelectedCard() {
            if (selectedCard.element) {
                selectedCard.element.classList.remove('selected-for-move');
            }
            selectedCard = { element: null, data: null, location: null, player: null, boardIndex: null, menuOrigin: null, isFaceDown: false, isRotated: false };
            isMovingCard = false;
        }

        function updateDeckCount(playerNum) {
            decks[playerNum].innerHTML = `<span>Deck</span>${players[playerNum].deck.length}`;
        }

        function updateGraveyardCount(playerNum) {
            graveyards[playerNum].innerHTML = `<span>Cimetière</span>${players[playerNum].graveyard.length}`;
        }

        function drawCard(playerNum) {
            const player = players[playerNum];
            if (player.deck.length > 0) {
                const card = player.deck.pop();
                player.hand.push(card);
                displayHand(playerNum);
                updateDeckCount(playerNum);
            } else {
                alert("Le deck est vide !");
            }
        }

        function displayHand(playerNum) {
            const handElement = hands[playerNum];
            handElement.innerHTML = '';
            players[playerNum].hand.forEach(cardData => {
                const cardElement = createCardElement(cardData);
                cardElement.dataset.location = 'hand';
                cardElement.dataset.player = playerNum;
                cardElement.addEventListener('click', () => openCardModal(cardElement, cardData, 'hand', playerNum));
                handElement.appendChild(cardElement);
            });
        }

        function displayBoard(playerNum) {
            const boardElement = boards[playerNum];
            boardElement.innerHTML = '';
            for (let i = 0; i < players[playerNum].board.length; i++) {
                const cardData = players[playerNum].board[i];
                if (cardData) {
                    const cardElement = createCardElement(cardData.data, cardData.isFaceDown, false, false, cardData.isRotated);
                    cardElement.dataset.location = 'board';
                    cardElement.dataset.player = playerNum;
                    cardElement.dataset.boardIndex = i; // Store board index
                    cardElement.addEventListener('click', () => openCardModal(cardElement, cardData.data, 'board', playerNum, i, cardData.isFaceDown, cardData.isRotated));
                    boardElement.appendChild(cardElement);
                } else {
                    const emptySlot = document.createElement('div');
                    emptySlot.classList.add('board-slot');
                    emptySlot.textContent = `Case ${i + 1}`;
                    emptySlot.dataset.player = playerNum;
                    emptySlot.dataset.boardIndex = i;
                    emptySlot.addEventListener('click', (e) => {
                        if (isMovingCard && selectedCard.menuOrigin === 'board' && selectedCard.location === 'hand') {
                            moveCardToBoard(selectedCard.data, parseInt(e.target.dataset.player), parseInt(e.target.dataset.boardIndex));
                        } else if (isMovingCard && selectedCard.location === 'board') {
                            // If moving from board to board, ensure the target is empty
                            if (players[selectedCard.player].board[parseInt(e.target.dataset.boardIndex)] === null) {
                                moveCardToBoard(selectedCard.data, parseInt(e.target.dataset.player), parseInt(e.target.dataset.boardIndex));
                            } else {
                                alert("Cette case est déjà occupée.");
                                resetSelectedCard();
                                cardModal.classList.remove('active');
                            }
                        }
                    });
                    boardElement.appendChild(emptySlot);
                }
            }
        }

        function openCardModal(element, cardData, location, player, boardIndex = -1, isFaceDown = false, isRotated = false) {
            selectedCard = { element, data: cardData, location, player, boardIndex, menuOrigin: location, isFaceDown, isRotated };
            modalCardDisplay.style.backgroundImage = `url(${isFaceDown ? 'images/dos.jpg' : cardData.path})`;
            modalCardDisplay.style.backgroundSize = 'cover';
            modalCardDisplay.style.backgroundPosition = 'center';
            cardModal.classList.add('active');

            // Hide/show buttons based on card location and state
            if (location === 'hand') {
                modalMoveCardBtn.style.display = 'block'; // Move to board
                modalGraveyardBtn.style.display = 'block';
                modalDeckBtn.style.display = 'block';
                modalRotateCardBtn.style.display = 'none'; // No rotation in hand
                modalFaceDownRotateCardBtn.style.display = 'none'; // No face-down in hand
                modalTakeToHandBtn.style.display = 'none'; // Already in hand
            } else if (location === 'board') {
                modalMoveCardBtn.style.display = 'block'; // Move on board or back to hand
                modalGraveyardBtn.style.display = 'block';
                modalDeckBtn.style.display = 'block';
                modalRotateCardBtn.style.display = 'block'; // Can rotate on board
                modalFaceDownRotateCardBtn.style.display = 'block'; // Can toggle face-down on board
                modalTakeToHandBtn.style.display = 'block'; // Can take from board to hand
            } else if (location === 'graveyard' || location === 'deck') {
                modalMoveCardBtn.style.display = 'block'; // Move to board
                modalGraveyardBtn.style.display = (location === 'graveyard') ? 'none' : 'block'; // Can't move to graveyard if already there
                modalDeckBtn.style.display = (location === 'deck') ? 'none' : 'block'; // Can't move to deck if already there
                modalRotateCardBtn.style.display = 'none'; // No rotation in graveyard/deck
                modalFaceDownRotateCardBtn.style.display = 'none'; // No face-down in graveyard/deck
                modalTakeToHandBtn.style.display = 'block'; // Can take from graveyard/deck to hand
            }
        }


        function removeCardFromLocation(cardId, location, playerNum, boardIndex = -1) {
            const player = players[playerNum];
            let removed = false;

            if (location === 'hand') {
                const index = player.hand.findIndex(card => card.id === cardId);
                if (index !== -1) {
                    player.hand.splice(index, 1);
                    removed = true;
                }
            } else if (location === 'board') {
                if (boardIndex !== -1 && player.board[boardIndex] && player.board[boardIndex].data.id === cardId) {
                    player.board[boardIndex] = null;
                    removed = true;
                }
            } else if (location === 'graveyard') {
                const index = player.graveyard.findIndex(card => card.id === cardId);
                if (index !== -1) {
                    player.graveyard.splice(index, 1);
                    removed = true;
                }
            } else if (location === 'deck') {
                const index = player.deck.findIndex(card => card.id === cardId);
                if (index !== -1) {
                    player.deck.splice(index, 1);
                    removed = true;
                }
            }

            if (removed) {
                displayHand(playerNum);
                displayBoard(playerNum);
                updateDeckCount(playerNum);
                updateGraveyardCount(playerNum);
            }
            return removed;
        }

        function prepareMoveOnBoard() {
            if (!selectedCard.data) return;

            // Only allow movement to board for cards from hand, deck, or graveyard
            if (selectedCard.location !== 'hand' && selectedCard.location !== 'board' && selectedCard.location !== 'deck' && selectedCard.location !== 'graveyard') {
                alert("Vous ne pouvez déplacer sur le plateau que des cartes de votre main, deck, cimetière ou déjà sur le plateau.");
                return;
            }

            isMovingCard = true;
            cardModal.classList.remove('active'); // Close current modal

            // Highlight targetable slots on the board
            const boardSlots = boards[selectedCard.player].querySelectorAll('.board-slot');
            boardSlots.forEach(slot => {
                slot.classList.add('targetable');
            });

            // If moving from board to board, the origin slot should also be targetable
            if (selectedCard.location === 'board' && selectedCard.element) {
                selectedCard.element.classList.add('targetable');
            }

            alert("Cliquez sur un emplacement du plateau pour déplacer la carte.");
        }


        function moveCardToBoard(cardData, playerNum, boardIndex) {
            const player = players[playerNum];

            // If moving from board to another board slot, clear the old slot first
            if (selectedCard.location === 'board' && selectedCard.boardIndex !== null) {
                player.board[selectedCard.boardIndex] = null;
            } else {
                // If moving from hand, deck, or graveyard, remove from original location
                removeCardFromLocation(cardData.id, selectedCard.location, playerNum, selectedCard.boardIndex);
            }

            // Place the card on the new board slot
            player.board[boardIndex] = { data: cardData, isFaceDown: selectedCard.isFaceDown, isRotated: selectedCard.isRotated };

            displayBoard(playerNum); // Refresh board display
            resetSelectedCard(); // Reset selected card state
            cardModal.classList.remove('active'); // Close modal
            deckGraveyardMenu.classList.remove('active'); // Close menu if open

            // Remove targetable class from all slots
            const boardSlots = boards[playerNum].querySelectorAll('.board-slot');
            boardSlots.forEach(slot => {
                slot.classList.remove('targetable');
            });
        }

        function moveToGraveyard() {
            if (!selectedCard.data) return;

            const player = players[selectedCard.player];
            // If card is already in graveyard, do nothing
            if (selectedCard.location === 'graveyard') {
                alert("Cette carte est déjà dans le cimetière.");
                resetSelectedCard();
                cardModal.classList.remove('active');
                return;
            }

            // Add card to graveyard
            player.graveyard.push(selectedCard.data);

            // Remove card from its original location
            removeCardFromLocation(selectedCard.data.id, selectedCard.location, selectedCard.player, selectedCard.boardIndex);

            updateGraveyardCount(selectedCard.player);
            resetSelectedCard();
            cardModal.classList.remove('active');
            deckGraveyardMenu.classList.remove('active');
        }

        function moveToDeck() {
            if (!selectedCard.data) return;

            const player = players[selectedCard.player];
            // If card is already in deck, do nothing
            if (selectedCard.location === 'deck') {
                alert("Cette carte est déjà dans le deck.");
                resetSelectedCard();
                cardModal.classList.remove('active');
                return;
            }

            // Add card to deck
            player.deck.push(selectedCard.data);
            shuffleArray(player.deck); // Shuffle deck after adding

            // Remove card from its original location
            removeCardFromLocation(selectedCard.data.id, selectedCard.location, selectedCard.player, selectedCard.boardIndex);

            updateDeckCount(selectedCard.player);
            resetSelectedCard();
            cardModal.classList.remove('active');
            deckGraveyardMenu.classList.remove('active');
        }

        function moveToHand() {
            if (!selectedCard.data) return;

            const playerHand = players[selectedCard.player].hand;
            const playerDeck = players[selectedCard.player].deck;
            const playerGraveyard = players[selectedCard.player].graveyard;

            // Vérifier si la carte est déjà dans la main pour éviter les doublons ou actions inutiles
            if (playerHand.some(card => card.id === selectedCard.data.id)) {
                console.log("La carte est déjà dans la main.");
                resetSelectedCard();
                cardModal.classList.remove('active');
                return;
            }

            // Ajouter la carte à la main
            playerHand.push(selectedCard.data);

            // Retirer la carte de son emplacement d'origine (deck ou cimetière ou plateau)
            if (selectedCard.location === 'deck') {
                const index = playerDeck.findIndex(card => card.id === selectedCard.data.id);
                if (index !== -1) {
                    playerDeck.splice(index, 1);
                    updateDeckCount(selectedCard.player);
                }
            } else if (selectedCard.location === 'graveyard') {
                const index = playerGraveyard.findIndex(card => card.id === selectedCard.data.id);
                if (index !== -1) {
                    playerGraveyard.splice(index, 1);
                    updateGraveyardCount(selectedCard.player);
                }
            } else if (selectedCard.location === 'board') {
                if (selectedCard.boardIndex !== -1 && players[selectedCard.player].board[selectedCard.boardIndex] && players[selectedCard.player].board[selectedCard.boardIndex].data.id === selectedCard.data.id) {
                    players[selectedCard.player].board[selectedCard.boardIndex] = null;
                }
            }

            displayHand(selectedCard.player); // Mettre à jour l'affichage de la main
            displayBoard(selectedCard.player); // Mettre à jour l'affichage du plateau (si la carte vient de là)
            resetSelectedCard(); // Réinitialiser la carte sélectionnée
            cardModal.classList.remove('active'); // Fermer la modale
            deckGraveyardMenu.classList.remove('active'); // Fermer le menu si ouvert
        }


        function openDeckGraveyardMenu(playerNum, origin) {
            menuTitle.textContent = (origin === 'deck') ? `Cartes du Deck (Joueur ${playerNum})` : `Cartes du Cimetière (Joueur ${playerNum})`;
            menuOptions.innerHTML = ''; // Clear existing options
            cardSelectionGrid.innerHTML = '';

            const cardsToDisplay = (origin === 'deck') ? players[playerNum].deck : players[playerNum].graveyard;

            if (cardsToDisplay.length === 0) {
                cardSelectionGrid.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Aucune carte ici.</p>';
            } else {
                cardsToDisplay.forEach(cardData => {
                    const cardElement = createCardElement(cardData);
                    cardElement.dataset.location = origin;
                    cardElement.dataset.player = playerNum;
                    cardElement.addEventListener('click', () => {
                        selectedCard = { element: cardElement, data: cardData, location: origin, player: playerNum, menuOrigin: origin };
                        openCardModal(cardElement, cardData, origin, playerNum);
                    });
                    cardSelectionGrid.appendChild(cardElement);
                });
            }
            deckGraveyardMenu.classList.add('active');
        }

        function rotateCard() {
            if (selectedCard.element && selectedCard.location === 'board') {
                const currentRotation = selectedCard.isRotated;
                selectedCard.isRotated = !currentRotation;

                // Update the actual card object on the board
                if (selectedCard.boardIndex !== null) {
                    players[selectedCard.player].board[selectedCard.boardIndex].isRotated = selectedCard.isRotated;
                }

                // Update the modal display immediately
                selectedCard.element.classList.toggle('rotated', selectedCard.isRotated);
                
                // Re-render the board to ensure correct dimensions are applied
                displayBoard(selectedCard.player);

                // Re-open modal to reflect changes and maintain context
                openCardModal(selectedCard.element, selectedCard.data, selectedCard.location, selectedCard.player, selectedCard.boardIndex, selectedCard.isFaceDown, selectedCard.isRotated);
            }
        }

        function toggleFaceDownAndRotate() {
            if (selectedCard.element && selectedCard.location === 'board') {
                selectedCard.isFaceDown = !selectedCard.isFaceDown;

                // Update the actual card object on the board
                if (selectedCard.boardIndex !== null) {
                    players[selectedCard.player].board[selectedCard.boardIndex].isFaceDown = selectedCard.isFaceDown;
                }

                // Update the modal display immediately
                modalCardDisplay.style.backgroundImage = `url(${selectedCard.isFaceDown ? 'images/dos.jpg' : selectedCard.data.path})`;

                // If face-down, it should also be rotated (as per typical YGO face-down defense position)
                if (selectedCard.isFaceDown && !selectedCard.isRotated) {
                    selectedCard.isRotated = true;
                    if (selectedCard.boardIndex !== null) {
                        players[selectedCard.player].board[selectedCard.boardIndex].isRotated = true;
                    }
                } else if (!selectedCard.isFaceDown && selectedCard.isRotated) {
                    // If turning face up, keep current rotation unless specified otherwise
                    // For simplicity, we can just leave it as is, or reset if desired.
                    // For now, let's just ensure it reflects the state.
                }

                displayBoard(selectedCard.player); // Re-render the board
                openCardModal(selectedCard.element, selectedCard.data, selectedCard.location, selectedCard.player, selectedCard.boardIndex, selectedCard.isFaceDown, selectedCard.isRotated); // Re-open modal to reflect changes
            }
        }



        function initializeDuel(deckName) {
            const selectedDeck = savedDecks[deckName];
            if (!selectedDeck || selectedDeck.length < MIN_DECK_SIZE) {
                alert(`Le deck "${deckName}" est invalide ou incomplet.`);
                return;
            }

            player1.deck = [...selectedDeck]; // Copie le deck sélectionné
            shuffleArray(player1.deck);
            player1.hand = [];
            player1.graveyard = [];
            player1.board = Array(15).fill(null); // Réinitialise le plateau
            player1.lp = 8000; // Points de vie
            player1.selectedDeckName = deckName; // Stocke le nom du deck pour référence

            // Mettre à jour l'affichage
            lpCounters['1'].textContent = player1.lp;
            updateDeckCount('1');
            updateGraveyardCount('1');
            displayHand('1');
            displayBoard('1');

            // Cacher le modal de sélection de deck et afficher le tab duel
            selectDeckModal.classList.remove('active');
            document.querySelector('.tab-button[data-tab="duel"]').click(); // Active le tab duel
        }


        // --- Initialisation et Écouteurs d'événements ---
        document.addEventListener('DOMContentLoaded', () => {
            generateAllAvailableCards();
            loadSavedDecks();
            updateCurrentDeckDisplay(); // Afficher un deck vide au démarrage

            // Gestion des onglets
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    const tab = button.dataset.tab;
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.getElementById(tab).classList.add('active');
                    button.classList.add('active');

                    // Si on passe au tab duel, afficher le modal de sélection de deck
                    if (tab === 'duel') {
                        renderAvailableDecksForSelection();
                        selectDeckModal.classList.add('active');
                    }
                });
            });

            // Gestion des événements du Deck Builder
            addNewCardBtn.addEventListener('click', () => {
                // Si aucun deck n'est en cours, initialiser un nouveau deck vide
                if (!currentEditingDeck.name) {
                    let newDeckName = prompt("Nommez votre nouveau deck :");
                    if (newDeckName) {
                        newDeckName = newDeckName.trim();
                        if (savedDecks[newDeckName]) {
                            alert("Un deck avec ce nom existe déjà. Veuillez choisir un nom différent ou éditer le deck existant.");
                            return;
                        }
                        currentEditingDeck.name = newDeckName;
                        currentEditingDeckNameInput.value = newDeckName;
                        currentEditingDeckNameInput.disabled = false;
                        updateCurrentDeckDisplay();
                    } else {
                        return; // L'utilisateur a annulé
                    }
                }
                showAddCardModal();
            });

            saveCurrentDeckBtn.addEventListener('click', saveCurrentDeck);
            cancelCurrentDeckBtn.addEventListener('click', cancelCurrentDeckEditing);
            clearCurrentDeckBtn.addEventListener('click', clearCurrentDeck);

            closeAddCardToDeckModal.addEventListener('click', () => addCardToDeckModal.classList.remove('active'));
            addCardToCurrentDeckBtn.addEventListener('click', addCardToCurrentDeck);
            cancelAddCardBtn.addEventListener('click', cancelAddCard);
            closeCardDetailModal.addEventListener('click', cancelAddCard); // Peut aussi fermer la modale de détail

            closeViewDeckModal.addEventListener('click', () => viewDeckModal.classList.remove('active'));


            // Gestion des événements du Duel
            decks['1'].addEventListener('click', () => drawCard('1')); // Draw card for player 1
            graveyards['1'].addEventListener('click', () => openDeckGraveyardMenu('1', 'graveyard'));

            lpCounters['1'].previousElementSibling.addEventListener('click', () => { // LP minus for player 1
                players['1'].lp = Math.max(0, players['1'].lp - 100);
                lpCounters['1'].textContent = players['1'].lp;
            });
            lpCounters['1'].nextElementSibling.addEventListener('click', () => { // LP plus for player 1
                players['1'].lp += 100;
                lpCounters['1'].textContent = players['1'].lp;
            });


            toggleHandBtns.forEach(button => {
                if (parseInt(button.dataset.player) === 1) {
                    button.addEventListener('click', (e) => {
                        const hand = hands[1];
                        hand.classList.toggle('hidden');
                        e.target.textContent = hand.classList.contains('hidden') ? 'Afficher Ma Main' : 'Masquer Ma Main';
                    });
                }
            });

            modalCloseBtn.addEventListener('click', () => {
                cardModal.classList.remove('active');
                resetSelectedCard();
            });
            modalMoveCardBtn.addEventListener('click', prepareMoveOnBoard);
            modalGraveyardBtn.addEventListener('click', moveToGraveyard);
            modalDeckBtn.addEventListener('click', moveToDeck);
            modalTakeToHandBtn.addEventListener('click', moveToHand); // NOUVEL ÉCOUTEUR
            
            // New event listeners for rotate and face-down buttons
            modalRotateCardBtn.addEventListener('click', rotateCard);
            modalFaceDownRotateCardBtn.addEventListener('click', toggleFaceDownAndRotate);


            menuCloseBtn.addEventListener('click', () => {
                deckGraveyardMenu.classList.remove('active');
                resetSelectedCard();
            });

            closeSelectDeckModal.addEventListener('click', () => selectDeckModal.classList.remove('active'));
            startDuelWithSelectedDeckBtn.addEventListener('click', startDuel);

            function renderAvailableDecksForSelection() {
                availableDecksList.innerHTML = '';
                if (Object.keys(savedDecks).length === 0) {
                    availableDecksList.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Aucun deck sauvegardé. Créez-en un dans l\'onglet "Gestion des Decks".</p>';
                    startDuelWithSelectedDeckBtn.disabled = true;
                    return;
                }
                startDuelWithSelectedDeckBtn.disabled = false;

                for (const name in savedDecks) {
                    const deckItem = document.createElement('div');
                    deckItem.classList.add('deck-item');
                    deckItem.style.backgroundColor = '#2c3e50'; // Override for selection modal

                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio';
                    radioInput.name = 'selectedDeckForDuel';
                    radioInput.value = name;
                    radioInput.id = `radio-${name}`;
                    radioInput.addEventListener('change', () => {
                        player1.selectedDeckName = name; // Store selected deck name
                    });

                    const label = document.createElement('label');
                    label.htmlFor = `radio-${name}`;
                    label.textContent = `${name} (${savedDecks[name].length} cartes)`;
                    label.style.flexGrow = '1';
                    label.style.cursor = 'pointer';

                    deckItem.appendChild(radioInput);
                    deckItem.appendChild(label);
                    availableDecksList.appendChild(deckItem);
                }

                // Select the first valid deck by default if available
                const firstDeckName = Object.keys(savedDecks)[0];
                if (firstDeckName) {
                    const firstRadio = document.getElementById(`radio-${firstDeckName}`);
                    if (firstRadio) {
                        firstRadio.checked = true;
                        player1.selectedDeckName = firstDeckName;
                    }
                }
            }

            function startDuel() {
                if (player1.selectedDeckName) {
                    initializeDuel(player1.selectedDeckName);
                } else {
                    alert("Veuillez sélectionner un deck pour démarrer le duel.");
                }
            }
        });
    </script>
</body>
</html>
